#!/usr/bin/env bash
# This script was generated by bashly 1.1.8 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
recipe_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe - Store redundant files in a recipe book to use them anytime, anywhere\n"
    echo

  else
    printf "recipe - Store redundant files in a recipe book to use them anytime, anywhere\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe COMMAND\n"
  printf "  recipe [COMMAND] --help | -h\n"
  printf "  recipe --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Recipe Book Commands:"
  printf "  %s   Create and setup a new recipe book\n" "init       "
  printf "  %s   Check your recipe book for potential problems\n" "doctor     "
  printf "  %s   Access git from your recipe book\n" "git        "
  printf "  %s   Clone a remote git repository\n" "clone      "
  printf "  %s   Show recipe book directory\n" "dir        "
  echo
  printf "%s\n" "Recipe Commands:"
  printf "  %s   Add a new recipe\n" "add        "
  printf "  %s   List all your recipes\n" "list       "
  printf "  %s   Use a recipe locally\n" "use        "
  printf "  %s   Remove a recipe\n" "remove     "
  printf "  %s   Edit a recipe\n" "edit       "
  printf "  %s   Show the content of a recipe\n" "show       "
  printf "  %s   Interactively filter recipes\n" "filter     "
  echo
  printf "%s\n" "Commands:"
  printf "  %s   Create a link to the recipe script\n" "link       "
  printf "  %s   Remove the link to the recipe script\n" "unlink     "
  printf "  %s   Update recipe to the latest version\n" "update     "
  printf "  %s   Command line completions\n" "completions"
  printf "  %s   Show recipe environment variables\n" "env        "
  printf "  %s   Start an interactive shell\n" "shell      "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "EDITOR"
    printf "    Editor to use for interactive commands\n"
    printf "    Default: vim\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "RECIPE_BOOK_DIR"
    printf "    Directory used to store recipes\n"
    printf "    Default: ${HOME}/recipe-book\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "RECIPE_INSTALL_DIR"
    printf "    Directory in which recipe was cloned\n"
    printf "    Default: ${HOME}/.recipe\n"
    echo

  fi
}

# :command.usage
recipe_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe init - Create and setup a new recipe book\n"
    echo

  else
    printf "recipe init - Create and setup a new recipe book\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe init [OPTIONS]\n"
  printf "  recipe init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Do not ask for confirmation\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe init\n"
    printf "  recipe init -y\n"
    echo

  fi
}

# :command.usage
recipe_doctor_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe doctor - Check your recipe book for potential problems\n"
    echo

  else
    printf "recipe doctor - Check your recipe book for potential problems\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe doctor\n"
  printf "  recipe doctor --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe doctor\n"
    echo

  fi
}

# :command.usage
recipe_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe add - Add a new recipe\n"
    echo

  else
    printf "recipe add - Add a new recipe\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe add FILE [NAME] [OPTIONS]\n"
  printf "  recipe add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Edit the recipe once it has been added\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Overwrite existing recipe\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FILE"
    printf "    Path to the recipe file\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the recipe\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe add -f Dockerfile docker/elixir\n"
    echo

  fi
}

# :command.usage
recipe_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe list - List all your recipes\n"
    echo

  else
    printf "recipe list - List all your recipes\n"
    echo

  fi

  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe list\n"
  printf "  recipe list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe list\n"
    echo

  fi
}

# :command.usage
recipe_git_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe git - Access git from your recipe book\n"
    echo

  else
    printf "recipe git - Access git from your recipe book\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe git COMMAND...\n"
  printf "  recipe git --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    echo "  COMMAND..."
    printf "    Command to run inside your recipe book\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe git log\n"
    printf "  recipe git remote add origin <repo>\n"
    echo

  fi
}

# :command.usage
recipe_use_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe use - Use a recipe locally\n"
    echo

  else
    printf "recipe use - Use a recipe locally\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe use [RECIPE] [DESTINATION] [OPTIONS]\n"
  printf "  recipe use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Edit the destination recipe\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "RECIPE"
    printf "    Name of the recipe\n"
    echo

    # :argument.usage
    printf "  %s\n" "DESTINATION"
    printf "    Destination to copy the recipe to\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe use\n"
    printf "  recipe use ssh-config ~/.ssh/config\n"
    echo

  fi
}

# :command.usage
recipe_remove_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe remove - Remove a recipe\n"
    echo

  else
    printf "recipe remove - Remove a recipe\n"
    echo

  fi

  printf "Alias: rm\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe remove [NAME] [OPTIONS]\n"
  printf "  recipe remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Do not ask for confirmation\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the recipe to remove\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe remove\n"
    printf "  recipe remove ssh-config --yes\n"
    echo

  fi
}

# :command.usage
recipe_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe edit - Edit a recipe\n"
    echo

  else
    printf "recipe edit - Edit a recipe\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe edit [NAME]\n"
  printf "  recipe edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the recipe to edit\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe edit\n"
    printf "  recipe edit ssh-config\n"
    echo

  fi
}

# :command.usage
recipe_clone_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe clone - Clone a remote git repository\n"
    echo

  else
    printf "recipe clone - Clone a remote git repository\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe clone URL [OPTIONS]\n"
  printf "  recipe clone --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Do not ask for confirmation\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "URL"
    printf "    Remote repository url\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe clone git@github:awesome-user/recipe-book.git --yes\n"
    echo

  fi
}

# :command.usage
recipe_link_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe link - Create a link to the recipe script\n"
    echo

  else
    printf "recipe link - Create a link to the recipe script\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe link PATH [OPTIONS]\n"
  printf "  recipe link --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--copy, -c"
    printf "    Copy the script instead of creating a symbolic link\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    Path to the link\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe link -c ~/.local/bin\n"
    echo

  fi
}

# :command.usage
recipe_unlink_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe unlink - Remove the link to the recipe script\n"
    echo

  else
    printf "recipe unlink - Remove the link to the recipe script\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe unlink PATH\n"
  printf "  recipe unlink --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    Path to the link\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe unlink ~/.local/bin\n"
    echo

  fi
}

# :command.usage
recipe_show_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe show - Show the content of a recipe\n"
    echo

  else
    printf "recipe show - Show the content of a recipe\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe show [NAME] [OPTIONS]\n"
  printf "  recipe show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--exec, -e EXECUTABLE"
    printf "    Executable used to show the recipe\n"
    printf "    Default: cat\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the recipe\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe show --exec bat\n"
    printf "  recipe show docker/express-js\n"
    echo

  fi
}

# :command.usage
recipe_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe update - Update recipe to the latest version\n"
    echo

  else
    printf "recipe update - Update recipe to the latest version\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe update\n"
  printf "  recipe update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
recipe_dir_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe dir - Show recipe book directory\n"
    echo

  else
    printf "recipe dir - Show recipe book directory\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe dir\n"
  printf "  recipe dir --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe dir\n"
    printf "  cd $(recipe dir)\n"
    echo

  fi
}

# :command.usage
recipe_filter_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe filter - Interactively filter recipes\n"
    echo

  else
    printf "recipe filter - Interactively filter recipes\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe filter\n"
  printf "  recipe filter --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe filter\n"
    echo

  fi
}

# :command.usage
recipe_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe completions - Command line completions\n"
    echo

  else
    printf "recipe completions - Command line completions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe completions\n"
  printf "  recipe completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  eval \"$(recipe completions)\"\n"
    echo

  fi
}

# :command.usage
recipe_env_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe env - Show recipe environment variables\n"
    echo

  else
    printf "recipe env - Show recipe environment variables\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe env\n"
  printf "  recipe env --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe env\n"
    echo

  fi
}

# :command.usage
recipe_shell_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe shell - Start an interactive shell\n"
    echo

  else
    printf "recipe shell - Start an interactive shell\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe shell [SHELL]\n"
  printf "  recipe shell --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SHELL"
    printf "\n"
    printf "    Allowed: sh, bash, zsh, fish\n"
    printf "    Default: $(basename $SHELL)\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/clean_directory.sh
clean_directory() {
    if [[ -d "${1}" ]] && [[ -z "$(ls -A "${1}")" ]]; then
        run_silent rmdir "${1}"
    fi
}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/confirm.sh
confirm() {
    local response=`gum input --prompt "${1} $(green "(yes|no)") " --placeholder ""`
    [[ "${response}" == "yes" ]] && return 0 || return 1
}

# src/lib/filter_recipe.sh
filter_recipe() {
    local recipes="$(find_recipe)"
    echo "${recipes}" | gum filter --placeholder "Select a recipe..."
}

# src/lib/filters.sh
filter_recipe_book_healthy() {
    if ! recipe_doctor_command &> /dev/null; then
        echo "$(yellow info:) your recipe book is not correctly setup"
        echo "$(yellow info:) consider running $(yellow_underlined recipe doctor)"
    fi
}

filter_recipe_book_not_empty() {
    if [[ -z "$(find_recipe)" ]]; then
        echo "Your recipe book is empty"
    fi
}

# src/lib/find_recipe.sh
find_recipe() {
    local recipes=$(run_git "ls-files")

    if [[ -n "${recipes}" ]]; then
        echo "${recipes}"
    fi
}

# src/lib/git_commit.sh
git_commit() {
    git -C "${RECIPE_BOOK_DIR}" commit -m "${1}"
}

# src/lib/run_git.sh
run_git() {
    git -C "${RECIPE_BOOK_DIR}" ${@}
}

# src/lib/run_silent.sh
run_silent() {
  command ${@} &> /dev/null
}

# src/lib/send_completions.sh
send_completions() {
  echo $'# recipe completion                                        -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_recipe_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_recipe_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'completions\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'doctor\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'filter\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'update\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'remove\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help --yes -h -y")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'unlink\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'clone\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help --yes -h -y")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'init\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help --yes -h -y")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'list\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'show\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--exec --help -e -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'edit\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'link\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--copy --help -c -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'env\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'dir\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'use\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--edit --help -e -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'git\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'add\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--edit --force --help -e -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'rm\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help --yes -h -y")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'ls\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_recipe_completions_filter "--help --version -h -v add clone completions dir doctor edit env filter git init link list ls remove rm show unlink update use")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _recipe_completions recipe'
  echo $''
  echo $'# ex: filetype=sh'
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/validations/validate_recipe_exists.sh
validate_recipe_exists() {
    [[ -f "${RECIPE_BOOK_DIR}/$1" ]] || echo "must be an existing recipe"
}

# src/lib/validations/validate_recipe_missing.sh
validate_recipe_missing() {
    [[ ! -f "${RECIPE_BOOK_DIR}/$1" ]] || echo "Your recipe book already contains that recipe."
}

# :command.command_functions
# :command.function
recipe_init_command() {
  # src/init_command.sh
  local auto_confirm="${args[--yes]}"

  if [[ -d "${RECIPE_BOOK_DIR}" ]]; then
      if [[ -n "${auto_confirm}" ]] || confirm "Overwrite current recipe book [$(magenta ${RECIPE_BOOK_DIR})] ?"; then
          \rm -rf "${RECIPE_BOOK_DIR}"
      else
          exit 1
      fi
  fi

  \mkdir "${RECIPE_BOOK_DIR}"

  run_silent pushd "${RECIPE_BOOK_DIR}"
  git init

  git switch -c `date "+%Y%m%d%H%m%S"`

  echo -e "$(green ✔) Created new recipe book"

  run_silent popd

}

# :command.function
recipe_doctor_command() {
  # src/doctor_command.sh
  local error=""

  if [[ ! -d "${RECIPE_BOOK_DIR}" ]]; then
      echo "$(yellow info:) your recipe book is missing at ${RECIPE_BOOK_DIR}"
      echo "$(yellow info:) consider running $(yellow_underlined recipe init)"

      error="yes"
  fi

  if [[ ! -d "${RECIPE_BOOK_DIR}/.git" ]]; then
      [[ -n "${error}" ]] && echo "" || error="yes"

      echo "$(yellow info:) your recipe book is not a git repository"
      echo "$(yellow info:) consider running $(yellow_underlined recipe init)"
  fi

  if [[ -n "${error}" ]]; then
      return 1
  else
      echo "$(green ✔) Your recipe book is correctly setup"
  fi

}

# :command.function
recipe_add_command() {
  # src/add_command.sh
  local file="${args[file]}"
  local recipe="${args[name]:-${file}}"

  local edit="${args[--edit]}"
  local force="${args[--force]}"

  if [[ -f "${RECIPE_BOOK_DIR}/${recipe}" ]] && [[ -z "${force}" ]]; then
      echo "$(red error:) Your recipe book already contains that recipe." && return 1
  fi

  local recipe_dir="$(dirname ${recipe})"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  # Directory in which the recipe will be stored
  local destination_dir="${RECIPE_BOOK_DIR}/${recipe_dir}"

  # Create intermediary directories if needed
  if [[ -n "${recipe_dir}" ]] && [[ ! -d "${destination_dir}" ]]; then
      \mkdir -p "${destination_dir}"
  fi

  [[ -n "${recipe}" ]] && \cp ${file} "${destination_path}"

  # Edit the file if the --edit flag was passed
  [[ -n "${edit}" ]] && ${EDITOR} "${destination_path}"

  if [[ -f "${destination_path}" ]]; then
      run_git add "${recipe}"

      timestamp=`date "+%Y%m%d%H%m%S"`
      git_commit "feat(${timestamp}): add recipe ${recipe}"

      echo "$(green ✔) New recipe added"
  else
      clean_directory "${destination_dir}"
      echo "$(red x) Recipe import aborted"
  fi

}

# :command.function
recipe_list_command() {
  # src/list_command.sh
  find_recipe

}

# :command.function
recipe_git_command() {
  # src/git_command.sh
  run_git ${other_args[*]}

}

# :command.function
recipe_use_command() {
  # src/use_command.sh
  local recipe="${args[recipe]}"
  local destination="${args[destination]}"
  local edit="${args[--edit]}"

  [[ -z "${recipe}" ]] && recipe="$(filter_recipe)"

  if [[ -z "${destination}" ]]; then
      destination=`gum input --placeholder "recipe name..." --value "$(basename ${recipe})" --prompt "$(blue ◉) Recipe name: "`

      [[ -z "${destination}" ]] && exit 1
  fi

  if [[ ! -f "${destination}" ]] || confirm "Overwrite ${destination}?"; then
      \cp -f "${RECIPE_BOOK_DIR}/${recipe}" "${destination}"
      echo "$(green ✔) Recipe ${recipe} is ready to use as $(magenta ${destination})"

      [[ -n "${edit}" ]] && $EDITOR "${destination}"
  fi

}

# :command.function
recipe_remove_command() {
  # src/remove_command.sh
  local recipe=${args['name']}
  local auto_confirm=${args['--yes']}

  [[ -z "${recipe}" ]] && recipe="$(filter_recipe)"

  local recipe_dir="$(dirname ${recipe})"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  # Directory in which the recipe will be stored
  local destination_dir="${RECIPE_BOOK_DIR}/${recipe_dir}"

  if [[ -n "${auto_confirm}" ]] || confirm "Remove recipe?"; then
      run_silent \rm "${destination_path}"
      clean_directory "${destination_dir}"

      run_git add "${recipe}"
      git_commit "feat: removed recipe '${recipe}'"

      echo "$(green ✔) Removed recipe ${recipe}"
  fi

}

# :command.function
recipe_edit_command() {
  # src/edit_command.sh
  local recipe="${args[name]}"

  [[ -z "${recipe}" ]] && recipe="$(filter_recipe)"

  local recipe_dir="$(dirname ${recipe})"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  # Directory in which the recipe will be stored
  local destination_dir="${RECIPE_BOOK_DIR}/${recipe_dir}"

  command $EDITOR "${destination_path}"

  local changes="$(run_git diff --name-only "${destination_path}")"

  if [[ -n "${changes}" ]]; then
      run_git add "${destination_path}"

      git_commit "feat: updated ${destination_path}"
      echo "$(green ✔) Recipe updated"
  fi

  clean_directory "${destination_dir}"

}

# :command.function
recipe_clone_command() {
  # src/clone_command.sh
  local url="${args[url]}"
  local auto_confirm="${args[--yes]}"

  if [[ ! -d "${RECIPE_BOOK_DIR}" ]] || [[ -n "${auto_confirm}" ]] || confirm "Overwrite current recipe book [$(magenta ${RECIPE_BOOK_DIR})] ?"; then
      [[ -d "${RECIPE_BOOK_DIR}" ]] && \rm -rf "${RECIPE_BOOK_DIR}"

      git clone "${url}" "${RECIPE_BOOK_DIR}"
      run_git switch -c `date "+%Y%m%d%H%m%S"`

      echo "$(green ✔) Your recipe book is ready"
  fi

}

# :command.function
recipe_link_command() {
  # src/link_command.sh
  local path="${args[path]}"
  local copy="${args[--copy]}"

  local source="${RECIPE_INSTALL_DIR}"

  if [[ -f "${path}/recipe" ]]; then
      echo "There is already a link in $(magenta "${path}")"
      exit 1
  fi

  if [[ ! -d "${source}" ]]; then
      echo "Source directory $(magenta "${source}") does not exist"
      exit 1
  fi

  if [[ ! -f "${source}/recipe" ]]; then
      echo "Script 'recipe' not found in $(magenta "${source}")"
      exit 1
  fi

  local executable=`test -n "${copy}" && echo "cp" || echo "ln -s"`

  command ${executable} "${source}/recipe" "${path}/recipe"
  echo "$(green ✔) Link created in $(magenta "${path}")"

}

# :command.function
recipe_unlink_command() {
  # src/unlink_command.sh
  local path="${args[path]}"

  if [[ -f "${path}/recipe" ]]; then
      run_silent rm -rf "${path}/recipe"
      echo "$(green ✔) Link removed from $(magenta "${path}")"
  else
      echo "No link found in $(magenta "${path}")"
      exit 1
  fi

}

# :command.function
recipe_show_command() {
  # src/show_command.sh
  local recipe="${args[name]}"
  local command="${args[--exec]}"

  [[ -z "${recipe}" ]] && recipe="$(filter_recipe)"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  command ${command} "${destination_path}"

}

# :command.function
recipe_update_command() {
  # src/update_command.sh
  if [[ ! -d "${RECIPE_INSTALL_DIR}" ]]; then
      echo "No recipe install directory. Check documentation for installation instruction."
      exit 1
  fi

  git -C "${RECIPE_INSTALL_DIR}" pull

}

# :command.function
recipe_dir_command() {
  # src/dir_command.sh
  echo "${RECIPE_BOOK_DIR}"

}

# :command.function
recipe_filter_command() {
  # src/filter_command.sh
  local recipes="$(find_recipe)"

  echo "${recipes}" | gum filter --placeholder "Select a recipe..."

}

# :command.function
recipe_completions_command() {
  # src/completions_command.sh
  send_completions

}

# :command.function
recipe_env_command() {
  # src/env_command.sh
  echo "RECIPE_BOOK_DIR=${RECIPE_BOOK_DIR}"
  echo "RECIPE_INSTALL_DIR=${RECIPE_INSTALL_DIR}"

}

# :command.function
recipe_shell_command() {
  # src/shell_command.sh
  local shell="${args[shell]:-${SHELL}}"

  run_silent pushd "${RECIPE_BOOK_DIR}"
  exec "${shell}"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        recipe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export EDITOR="${EDITOR:-vim}"
  export RECIPE_BOOK_DIR="${RECIPE_BOOK_DIR:-${HOME}/recipe-book}"
  export RECIPE_INSTALL_DIR="${RECIPE_INSTALL_DIR:-${HOME}/.recipe}"

  env_var_names+=("EDITOR")
  env_var_names+=("RECIPE_BOOK_DIR")
  env_var_names+=("RECIPE_INSTALL_DIR")

  # :command.dependencies_filter
  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    exit 1
  fi

  if command -v gum >/dev/null 2>&1; then
    deps['gum']="$(command -v gum | head -n1)"
  else
    printf "missing dependency: gum\n" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      recipe_init_parse_requirements "$@"
      shift $#
      ;;

    doctor)
      action="doctor"
      shift
      recipe_doctor_parse_requirements "$@"
      shift $#
      ;;

    add)
      action="add"
      shift
      recipe_add_parse_requirements "$@"
      shift $#
      ;;

    list | ls)
      action="list"
      shift
      recipe_list_parse_requirements "$@"
      shift $#
      ;;

    git)
      action="git"
      shift
      recipe_git_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      recipe_use_parse_requirements "$@"
      shift $#
      ;;

    remove | rm)
      action="remove"
      shift
      recipe_remove_parse_requirements "$@"
      shift $#
      ;;

    edit)
      action="edit"
      shift
      recipe_edit_parse_requirements "$@"
      shift $#
      ;;

    clone)
      action="clone"
      shift
      recipe_clone_parse_requirements "$@"
      shift $#
      ;;

    link)
      action="link"
      shift
      recipe_link_parse_requirements "$@"
      shift $#
      ;;

    unlink)
      action="unlink"
      shift
      recipe_unlink_parse_requirements "$@"
      shift $#
      ;;

    show)
      action="show"
      shift
      recipe_show_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      recipe_update_parse_requirements "$@"
      shift $#
      ;;

    dir)
      action="dir"
      shift
      recipe_dir_parse_requirements "$@"
      shift $#
      ;;

    filter)
      action="filter"
      shift
      recipe_filter_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      recipe_completions_parse_requirements "$@"
      shift $#
      ;;

    env)
      action="env"
      shift
      recipe_env_parse_requirements "$@"
      shift $#
      ;;

    shell)
      action="shell"
      shift
      recipe_shell_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      recipe_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
recipe_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
recipe_doctor_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_doctor_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="doctor"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
recipe_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['file']+x} ]]; then
          args['file']=$1
          shift
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['file']+x} ]]; then
    printf "missing required argument: FILE\nusage: recipe add FILE [NAME] [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['file'] && -n $(validate_file_exists "${args['file']:-}") ]]; then
    printf "$(red error:) %s %s\n" "FILE" "$(validate_file_exists "${args['file']:-}")" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_recipe_book_healthy)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_recipe_book_healthy)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_git_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_git_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="git"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

  # :command.catch_all_filter
  if [[ ${#other_args[@]} -eq 0 ]]; then
    printf "missing required argument: COMMAND...\nusage: recipe git COMMAND...\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['recipe']+x} ]]; then
          args['recipe']=$1
          shift
        elif [[ -z ${args['destination']+x} ]]; then
          args['destination']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.validations
  # :argument.validations
  if [[ -v args['recipe'] && -n $(validate_recipe_exists "${args['recipe']:-}") ]]; then
    printf "$(red error:) %s %s\n" "RECIPE" "$(validate_recipe_exists "${args['recipe']:-}")" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_recipe_book_healthy)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_not_empty)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_remove_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.validations
  # :argument.validations
  if [[ -v args['name'] && -n $(validate_recipe_exists "${args['name']:-}") ]]; then
    printf "$(red error:) %s %s\n" "NAME" "$(validate_recipe_exists "${args['name']:-}")" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_recipe_book_healthy)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_not_empty)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_edit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.validations
  # :argument.validations
  if [[ -v args['name'] && -n $(validate_recipe_exists "${args['name']:-}") ]]; then
    printf "$(red error:) %s %s\n" "NAME" "$(validate_recipe_exists "${args['name']:-}")" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_recipe_book_healthy)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_clone_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_clone_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="clone"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['url']+x} ]]; then
          args['url']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['url']+x} ]]; then
    printf "missing required argument: URL\nusage: recipe clone URL [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_link_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_link_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="link"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --copy | -c)

        # :flag.case_no_arg
        args['--copy']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: recipe link PATH [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_unlink_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_unlink_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="unlink"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: recipe unlink PATH\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_show_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --exec | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--exec']="$2"
          shift
          shift
        else
          printf "%s\n" "--exec requires an argument: --exec, -e EXECUTABLE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--exec']:-} ]] || args['--exec']="cat"

  # :command.validations
  # :argument.validations
  if [[ -v args['name'] && -n $(validate_recipe_exists "${args['name']:-}") ]]; then
    printf "$(red error:) %s %s\n" "NAME" "$(validate_recipe_exists "${args['name']:-}")" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_recipe_book_healthy)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_not_empty)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
recipe_dir_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_dir_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="dir"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_recipe_book_healthy)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_filter_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_filter_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="filter"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_recipe_book_healthy)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
recipe_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
recipe_env_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="env"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
recipe_shell_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_shell_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="shell"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['shell']+x} ]]; then
          args['shell']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['shell']:-} ]] || args['shell']="$(basename $SHELL)"

  # :command.whitelist_filter
  if [[ -n ${args['shell']:-} ]] && [[ ! ${args['shell']:-} =~ ^(sh|bash|zsh|fish)$ ]]; then
    printf "%s\n" "shell must be one of: sh, bash, zsh, fish" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.9.4"
  long_usage=''
  set -e

  # :command.environment_variables_default
  export EDITOR="${EDITOR:-vim}"
  export RECIPE_BOOK_DIR="${RECIPE_BOOK_DIR:-${HOME}/recipe-book}"
  export RECIPE_INSTALL_DIR="${RECIPE_INSTALL_DIR:-${HOME}/.recipe}"

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "init") recipe_init_command ;;
    "doctor") recipe_doctor_command ;;
    "add") recipe_add_command ;;
    "list") recipe_list_command ;;
    "git") recipe_git_command ;;
    "use") recipe_use_command ;;
    "remove") recipe_remove_command ;;
    "edit") recipe_edit_command ;;
    "clone") recipe_clone_command ;;
    "link") recipe_link_command ;;
    "unlink") recipe_unlink_command ;;
    "show") recipe_show_command ;;
    "update") recipe_update_command ;;
    "dir") recipe_dir_command ;;
    "filter") recipe_filter_command ;;
    "completions") recipe_completions_command ;;
    "env") recipe_env_command ;;
    "shell") recipe_shell_command ;;
  esac
}

initialize
run "$@"
