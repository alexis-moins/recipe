#!/usr/bin/env bash
# This script was generated by bashly 1.0.5 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

version_command() {
  echo "$version"
}

recipe_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe - Store files/templates in a recipe book to use them anytime, anywhere\n"
    echo

  else
    printf "recipe - Store files/templates in a recipe book to use them anytime, anywhere\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe COMMAND\n"
  printf "  recipe [COMMAND] --help | -h\n"
  printf "  recipe --version | -v\n"
  echo

  printf "%s\n" "Commands:"
  printf "  %s   Add a new recipe\n" "add   "
  printf "  %s   List all your recipes\n" "list  "
  printf "  %s   Access git from your recipe book\n" "git   "
  printf "  %s   Use a recipe locally\n" "use   "
  printf "  %s   Remove a recipe\n" "remove"
  printf "  %s   Edit a recipe\n" "edit  "
  printf "  %s   Clone a remote git repository\n" "clone "
  printf "  %s   Create a symbolic link to the recipe executable\n" "link  "
  printf "  %s   Show the content of a recipe\n" "show  "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    printf "%s\n" "Environment Variables:"

    printf "  %s\n" "EDITOR"
    printf "    Editor to use for interactive commands\n"
    printf "    Default: vim\n"
    echo

    printf "  %s\n" "RECIPE_BOOK_DIR"
    printf "    Directories used to store recipes\n"
    printf "    Default: ${HOME}/recipe-book\n"
    echo

  fi
}

recipe_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe add - Add a new recipe\n"
    echo

  else
    printf "recipe add - Add a new recipe\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe add NAME [OPTIONS]\n"
  printf "  recipe add --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--from, -f FILE"
    printf "    Use the following file for this recipe\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    Name of the new recipe\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe add docker/express-js\n"
    printf "  recipe add ssh-config -f ~/.ssh/config\n"
    echo

  fi
}

recipe_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe list - List all your recipes\n"
    echo

  else
    printf "recipe list - List all your recipes\n"
    echo

  fi

  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe list\n"
  printf "  recipe list --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe list\n"
    echo

  fi
}

recipe_git_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe git - Access git from your recipe book\n"
    echo

  else
    printf "recipe git - Access git from your recipe book\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe git COMMAND...\n"
  printf "  recipe git --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    echo "  COMMAND..."
    printf "    Command to run inside the recipe book\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe git log\n"
    printf "  recipe git remote add origin <repo>\n"
    echo

  fi
}

recipe_use_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe use - Use a recipe locally\n"
    echo

  else
    printf "recipe use - Use a recipe locally\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe use [NAME] [OPTIONS]\n"
  printf "  recipe use --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--destination, -d DESTINATION"
    printf "    Destination path for the recipe\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    Name of the recipe\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe use\n"
    printf "  recipe use ssh-config -d ~/.ssh/config\n"
    echo

  fi
}

recipe_remove_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe remove - Remove a recipe\n"
    echo

  else
    printf "recipe remove - Remove a recipe\n"
    echo

  fi

  printf "Alias: rm\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe remove [NAME] [OPTIONS]\n"
  printf "  recipe remove --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--yes, -y"
    printf "    Do not ask for confirmation\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    Name of the recipe to remove\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe remove\n"
    printf "  recipe remove ssh-config --yes\n"
    echo

  fi
}

recipe_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe edit - Edit a recipe\n"
    echo

  else
    printf "recipe edit - Edit a recipe\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe edit [NAME]\n"
  printf "  recipe edit --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    Name of the recipe to edit\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe edit\n"
    printf "  recipe edit ssh-config\n"
    echo

  fi
}

recipe_clone_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe clone - Clone a remote git repository\n"
    echo

  else
    printf "recipe clone - Clone a remote git repository\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe clone URL [OPTIONS]\n"
  printf "  recipe clone --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--yes, -y"
    printf "    Do not ask for confirmation\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "URL"
    printf "    Remote repository url\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe clone git@github:awesome-user/recipe-book.git --yes\n"
    echo

  fi
}

recipe_link_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe link - Create a symbolic link to the recipe executable\n"
    echo

  else
    printf "recipe link - Create a symbolic link to the recipe executable\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe link [PATH] [OPTIONS]\n"
  printf "  recipe link --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--remove, -r"
    printf "    Remove the symbolic link instead\n"
    echo

    printf "  %s\n" "--source, -s SOURCE"
    printf "    Path to the directory containing the recipe script\n"
    printf "    Default: ${HOME}/.recipe\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "PATH"
    printf "    Path to the symbolic link\n"
    printf "    Default: ${HOME}/.local/bin\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe link /usr/local/bin\n"
    printf "  recipe link --source ~/scripts/recipe --remove\n"
    echo

  fi
}

recipe_show_usage() {
  if [[ -n $long_usage ]]; then
    printf "recipe show - Show the content of a recipe\n"
    echo

  else
    printf "recipe show - Show the content of a recipe\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  recipe show [NAME]\n"
  printf "  recipe show --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    Name of the recipe\n"
    echo

    printf "%s\n" "Environment Variables:"

    printf "  %s\n" "RECIPE_SHOW_COMMAND"
    printf "    Executable used to print the recipe\n"
    printf "    Default: cat\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe show\n"
    printf "  recipe show docker/express-js\n"
    echo

  fi
}

normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

clean_directory() {
    if [[ -d "${1}" ]] && [[ -z "$(ls -A "${1}")" ]]; then
        run_silent \rmdir "${1}"
    fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

confirm() {
    local response=`gum input --prompt "${1} $(green "(yes/no)") "`
    [[ "${response}" == "yes" ]] && return 0 || return 1
}

ensure_recipe_book_not_empty() {
    local candidates="$(find_recipe)"

    if [[ -z "${candidates}" ]]; then
        echo "Your recipe book is empty"
        exit 1
    fi
}

filter_recipe() {
    local recipes="$(find_recipe)"
    echo "${recipes}" | gum filter --placeholder "Select a recipe..."
}

find_recipe() {
    run_silent pushd "${RECIPE_BOOK_DIR}"
    local recipes="$(\fd --color never --hidden --type file .)"

    run_silent popd
    echo "${recipes}"
}

git_commit() {
    git -C "${RECIPE_BOOK_DIR}" commit -m "${1}"
}

run_git() {
    git -C "${RECIPE_BOOK_DIR}" ${@}
}

run_silent() {
  ${@} &> /dev/null
}

validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

validate_recipe_exists() {
    [[ -f "${RECIPE_BOOK_DIR:-${HOME}/recipe-book}/$1" ]] || echo "must be an existing recipe"
}

validate_recipe_missing() {
    [[ ! -f "${RECIPE_BOOK_DIR:-${HOME}/recipe-book}/$1" ]] || echo "Your recipe book already contains that recipe."
}

recipe_add_command() {
  local recipe=${args['name']}
  local file=${args['--from']}

  local recipe_dir="$(dirname ${recipe})"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  # Directory in which the recipe will be stored
  local destination_dir="${RECIPE_BOOK_DIR}/${recipe_dir}"

  if [[ -n "${recipe_dir}" ]] && [[ ! -d "${destination_dir}" ]]; then
      run_silent \mkdir "${destination_dir}"
  fi

  [[ -n ${file} ]] && \cp ${file} "${destination_path}" || ${EDITOR} "${destination_path}"

  if [[ -f "${destination_path}" ]]; then
      run_git add "${recipe}"
      git_commit "feat: added recipe '${recipe}'"

      echo "$(green ✔) New recipe added"
  else
      clean_directory "${destination_dir}"
      echo "The recipe was not added to your recipe book"
  fi

}

recipe_list_command() {
  find_recipe

}

recipe_git_command() {
  run_git ${other_args[*]}

}

recipe_use_command() {
  local recipe="${args[name]}"
  local destination="${args[--destination]}"

  ensure_recipe_book_not_empty
  [[ -z "${recipe}" ]] && recipe="$(filter_recipe)"

  [[ -z "${destination}" ]] && destination="$(basename ${recipe})"

  if [[ ! -f "${destination}" ]] || confirm "Overwrite ${destination}?"; then
      local templates=`rg --only-matching "\{\{(.*)\}\}" --replace '$1' "${RECIPE_BOOK_DIR}/${recipe}"`

      if [[ -z "${templates}" ]]; then
          \cp -f "${RECIPE_BOOK_DIR}/${recipe}" "${destination}"
          echo "$(green ✔) Your recipe is ready to use."
      else
          local expression=""

          for template in ${templates}; do
              [[ -n "${expression}" ]] && expression+=";"
              local response=`gum input --prompt "${template}: "`

              [[ -z "${response}" ]] && exit 1

              echo "${template}: $(cyan ${response})"

              expression+="s/{{ ${template} }}/${response}/"
          done

          sed "${expression}" "${RECIPE_BOOK_DIR}/${recipe}" > "${destination}"
          echo -e "\n$(green ✔) Your recipe is ready to use."
      fi
  fi

}

recipe_remove_command() {
  local recipe=${args['name']}
  local auto_confirm=${args['--yes']}

  ensure_recipe_book_not_empty
  [[ -z "${recipe}" ]] && recipe="$(filter_recipe)"

  local recipe_dir="$(dirname ${recipe})"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  # Directory in which the recipe will be stored
  local destination_dir="${RECIPE_BOOK_DIR}/${recipe_dir}"

  if [[ -n "${auto_confirm}" ]] || confirm "Remove recipe?"; then
      \rm "${destination_path}"

      clean_directory "${destination_dir}"

      run_git add "${recipe}"
      git_commit "feat: removed recipe '${recipe}'"

      echo "$(green ✔) Removed recipe ${recipe}"
  fi

}

recipe_edit_command() {
  local recipe="${args[name]}"

  [[ -z "${recipe}" ]] && recipe="$(filter_recipe)"

  local recipe_dir="$(dirname ${recipe})"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  # Directory in which the recipe will be stored
  local destination_dir="${RECIPE_BOOK_DIR}/${recipe_dir}"

  command $EDITOR "${destination_path}"

  local changes="$(run_git diff --name-only "${destination_path}")"

  if [[ -n "${changes}" ]]; then
      run_git add "${destination_path}"

      git_commit "feat: updated ${destination_path}"
      echo "$(green ✔) Recipe updated"
  fi

  clean_directory "${destination_dir}"

}

recipe_clone_command() {
  local url="${args[url]}"
  local auto_confirm="${args[--yes]}"

  if [[ -n "${auto_confirm}" ]] || "${deps[gum]}" confirm "Overwrite current recipe book?"; then
      run_silent \rm -rf "${RECIPE_BOOK_DIR}"
      git clone "${url}" "${RECIPE_BOOK_DIR}"

      echo "$(green ✔) Your recipe book is ready"
  fi

}

recipe_link_command() {
  local path="${args[path]}"

  local source="${args[--source]}"
  local remove="${args[--remove]}"

  if [[ -n "${remove}" ]]; then
      if [[ -L "${path}/recipe" ]]; then
          run_silent \rm -rf "${path}/recipe"
          echo "$(green ✔) Link removed from $(magenta "${path}")"
      else
          echo "$(red error:) no link was found in $(magenta "${path}")"
          exit 1
      fi
  else
      if [[ -L "${path}/recipe" ]]; then
          echo "$(red error:) there is already a link in $(magenta "${path}")"
          exit 1
      fi

      if [[ ! -d "${source}" ]]; then
          echo "$(red error: ) source directory $(magenta "${source}") does not exist"
          exit 1
      fi

      source=`realpath "${source}"`

      if [[ ! -f "${source}/recipe" ]]; then
          echo "$(red error:) recipe script not found in $(magenta "${source}")"
          exit 1
      fi

      run_silent \ln -s "${source}/recipe" "${path}/recipe"
      echo "$(green ✔) Link created in $(magenta "${path}")"
  fi

}

recipe_show_command() {
  local recipe="${args[name]}"

  [[ -z "${recipe}" ]] && recipe="$(filter_recipe)"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  command ${RECIPE_SHOW_COMMAND} "${destination_path}"

}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        recipe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  export EDITOR="${EDITOR:-vim}"
  export RECIPE_BOOK_DIR="${RECIPE_BOOK_DIR:-${HOME}/recipe-book}"

  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    exit 1
  fi

  if command -v fd >/dev/null 2>&1; then
    deps['fd']="$(command -v fd | head -n1)"
  else
    printf "missing dependency: fd\n" >&2
    exit 1
  fi

  if command -v gum >/dev/null 2>&1; then
    deps['gum']="$(command -v gum | head -n1)"
  else
    printf "missing dependency: gum\n" >&2
    exit 1
  fi

  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      recipe_add_parse_requirements "$@"
      shift $#
      ;;

    list | ls)
      action="list"
      shift
      recipe_list_parse_requirements "$@"
      shift $#
      ;;

    git)
      action="git"
      shift
      recipe_git_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      recipe_use_parse_requirements "$@"
      shift $#
      ;;

    remove | rm)
      action="remove"
      shift
      recipe_remove_parse_requirements "$@"
      shift $#
      ;;

    edit)
      action="edit"
      shift
      recipe_edit_parse_requirements "$@"
      shift $#
      ;;

    clone)
      action="clone"
      shift
      recipe_clone_parse_requirements "$@"
      shift $#
      ;;

    link)
      action="link"
      shift
      recipe_link_parse_requirements "$@"
      shift $#
      ;;

    show)
      action="show"
      shift
      recipe_show_parse_requirements "$@"
      shift $#
      ;;

    "")
      recipe_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

recipe_add_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="add"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --from | -f)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_file_exists "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--from, -f FILE" "$(validate_file_exists "$2")" >&2
            exit 1
          fi

          args['--from']="$2"
          shift
          shift
        else
          printf "%s\n" "--from requires an argument: --from, -f FILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then

          if [[ -n $(validate_recipe_missing "$1") ]]; then
            printf "validation error in %s:\n%s\n" "NAME" "$(validate_recipe_missing "$1")" >&2
            exit 1
          fi

          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: recipe add NAME [OPTIONS]\n" >&2
    exit 1
  fi

}

recipe_list_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="list"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

recipe_git_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_git_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="git"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)

        other_args+=("$1")
        shift

        ;;

    esac
  done

  if [[ ${#other_args[@]} -eq 0 ]]; then
    printf "missing required argument: COMMAND...\nusage: recipe git COMMAND...\n" >&2
    exit 1
  fi

}

recipe_use_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="use"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --destination | -d)

        if [[ -n ${2+x} ]]; then

          args['--destination']="$2"
          shift
          shift
        else
          printf "%s\n" "--destination requires an argument: --destination, -d DESTINATION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then

          if [[ -n $(validate_recipe_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "NAME" "$(validate_recipe_exists "$1")" >&2
            exit 1
          fi

          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

recipe_remove_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="remove"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --yes | -y)

        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then

          if [[ -n $(validate_recipe_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "NAME" "$(validate_recipe_exists "$1")" >&2
            exit 1
          fi

          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

recipe_edit_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="edit"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then

          if [[ -n $(validate_recipe_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "NAME" "$(validate_recipe_exists "$1")" >&2
            exit 1
          fi

          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

recipe_clone_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_clone_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="clone"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --yes | -y)

        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['url']+x} ]]; then

          args['url']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['url']+x} ]]; then
    printf "missing required argument: URL\nusage: recipe clone URL [OPTIONS]\n" >&2
    exit 1
  fi

}

recipe_link_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_link_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="link"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --remove | -r)

        args['--remove']=1
        shift
        ;;

      --source | -s)

        if [[ -n ${2+x} ]]; then

          args['--source']="$2"
          shift
          shift
        else
          printf "%s\n" "--source requires an argument: --source, -s SOURCE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['path']+x} ]]; then

          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  [[ -n ${args['path']:-} ]] || args['path']="${HOME}/.local/bin"
  [[ -n ${args['--source']:-} ]] || args['--source']="${HOME}/.recipe"

}

recipe_show_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  export RECIPE_SHOW_COMMAND="${RECIPE_SHOW_COMMAND:-cat}"

  action="show"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then

          if [[ -n $(validate_recipe_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "NAME" "$(validate_recipe_exists "$1")" >&2
            exit 1
          fi

          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  export EDITOR="${EDITOR:-vim}"
  export RECIPE_BOOK_DIR="${RECIPE_BOOK_DIR:-${HOME}/recipe-book}"

  if [[ ! -d "${RECIPE_BOOK_DIR}/.git" ]]; then
      run_silent \mkdir "$RECIPE_BOOK_DIR"
      run_silent pushd "$RECIPE_BOOK_DIR"

      run_silent git init
      run_silent popd

      echo "$(green ✔) Initialized recipe book."
  fi

}

run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "add") recipe_add_command ;;
    "list") recipe_list_command ;;
    "git") recipe_git_command ;;
    "use") recipe_use_command ;;
    "remove") recipe_remove_command ;;
    "edit") recipe_edit_command ;;
    "clone") recipe_clone_command ;;
    "link") recipe_link_command ;;
    "show") recipe_show_command ;;
  esac
}

initialize
run "$@"
