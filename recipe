#!/usr/bin/env bash
# This script was generated by bashly 1.2.2 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "$(red pm:) bash version 4 or higher is required\n" >&2
  exit 1
fi

version_command() {
  echo "$version"
}

recipe_usage() {
  printf "recipe - store redundant files in a recipe book to use them anytime, anywhere\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe COMMAND\n"
  printf "  recipe [COMMAND] --help | -h\n"
  printf "  recipe --version | -v\n"
  echo

  printf "%s\n" "Recipe Commands:"
  printf "  %s   Add a new recipe\n" "add    "
  printf "  %s   List all your recipes\n" "list   "
  printf "  %s   Filter recipes\n" "filter "
  printf "  %s   Use a recipe locally\n" "use    "
  printf "  %s   Remove a recipe\n" "remove "
  printf "  %s   Edit a recipe\n" "edit   "
  printf "  %s   Show the content of a recipe\n" "show   "
  echo
  printf "%s\n" "Commands:"
  printf "  %s   Print environment information\n" "env    "
  printf "  %s   List, filter, and add recipe books\n" "book   "
  echo
  printf "%s\n" "Git Commands:"
  printf "  %s   Show the status of your recipe book\n" "status "
  printf "  %s   Stage files interactively\n" "stage  "
  printf "  %s   Unstage files interactively\n" "unstage"
  printf "  %s   Restore unstaged files interactively\n" "restore"
  printf "  %s   Show interactive diff with last commit\n" "diff   "
  printf "  %s   Commit changes\n" "commit "
  printf "  %s   Run git commands within your recipe book\n" "git    "
  echo
  printf "%s\n" "Recipe Book Commands:"
  printf "  %s   Navigate to your recipe book in a new shell\n" "cd     "
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    printf "%s\n" "Environment Variables:"

    printf "  %s\n" "RECIPE_SHOW_CMD"
    printf "    Command used to show recipes\n"
    printf "    %s\n" "Default: cat"
    echo

  fi
}

recipe_add_usage() {
  printf "recipe add - Add a new recipe\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe add FILE [NAME]\n"
  printf "  recipe add --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "FILE"
    printf "    Path to the recipe file\n"
    echo

    printf "  %s\n" "NAME"
    printf "    Name of the recipe\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe add Dockerfile\n"
    printf "  recipe add Dockerfile docker/elixir\n"
    echo

  fi
}

recipe_list_usage() {
  printf "recipe list - List all your recipes\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe list\n"
  printf "  recipe list --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe list\n"
    echo

  fi
}

recipe_filter_usage() {
  printf "recipe filter - Filter recipes\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe filter\n"
  printf "  recipe filter --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe filter\n"
    echo

  fi
}

recipe_use_usage() {
  printf "recipe use - Use a recipe locally\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe use RECIPE [DESTINATION]\n"
  printf "  recipe use --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "RECIPE"
    printf "    Name of the recipe\n"
    echo

    printf "  %s\n" "DESTINATION"
    printf "    Destination to copy the recipe to\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe use\n"
    printf "  recipe use ssh-config ~/.ssh/config\n"
    echo

  fi
}

recipe_remove_usage() {
  printf "recipe remove - Remove a recipe\n\n"
  printf "Alias: rm\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe remove NAME\n"
  printf "  recipe remove --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    Name of the recipe to remove\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe remove docker/elixir\n"
    echo

  fi
}

recipe_edit_usage() {
  printf "recipe edit - Edit a recipe\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe edit NAME\n"
  printf "  recipe edit --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    Name of the recipe to edit\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe edit LICENSE/mit\n"
    echo

  fi
}

recipe_show_usage() {
  printf "recipe show - Show the content of a recipe\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe show NAME [OPTIONS]\n"
  printf "  recipe show --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--exec, -x EXECUTABLE"
    printf "    Command used to show the recipe\n"
    printf "    %s\n" "Default: ${RECIPE_SHOW_CMD}"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    Name of the recipe\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe show LICENSE/mit\n"
    printf "  recipe show LICENSE/mit -x bat\n"
    echo

  fi
}

recipe_env_usage() {
  printf "recipe env - Print environment information\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe env\n"
  printf "  recipe env --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe env\n"
    echo

  fi
}

recipe_status_usage() {
  printf "recipe status - Show the status of your recipe book\n\n"
  printf "Alias: st\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe status [OPTIONS]\n"
  printf "  recipe status --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--short, -s"
    printf "    Give the output in a short format\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe status\n"
    echo

  fi
}

recipe_stage_usage() {
  printf "recipe stage - Stage files interactively\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe stage\n"
  printf "  recipe stage --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe stage\n"
    echo

  fi
}

recipe_unstage_usage() {
  printf "recipe unstage - Unstage files interactively\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe unstage\n"
  printf "  recipe unstage --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe unstage\n"
    echo

  fi
}

recipe_restore_usage() {
  printf "recipe restore - Restore unstaged files interactively\n\n"
  printf "Alias: rs, undo\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe restore\n"
  printf "  recipe restore --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe restore\n"
    echo

  fi
}

recipe_diff_usage() {
  printf "recipe diff - Show interactive diff with last commit\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe diff [OPTIONS]\n"
  printf "  recipe diff --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--staged, -s"
    printf "    Only show diff for staged files\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe diff\n"
    printf "  recipe diff --staged\n"
    echo

  fi
}

recipe_commit_usage() {
  printf "recipe commit - Commit changes\n\n"
  printf "Alias: ci\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe commit [MESSAGE]\n"
  printf "  recipe commit --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "MESSAGE"
    printf "    Commit message\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe commit\n"
    echo

  fi
}

recipe_cd_usage() {
  printf "recipe cd - Navigate to your recipe book in a new shell\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe cd\n"
  printf "  recipe cd --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe cd\n"
    echo

  fi
}

recipe_git_usage() {
  printf "recipe git - Run git commands within your recipe book\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe git [--] COMMANDS...\n"
  printf "  recipe git --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    echo "  COMMANDS..."
    printf "    Commands\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe git switch -c <new-branch>\n"
    echo

  fi
}

recipe_book_usage() {
  printf "recipe book - List, filter, and add recipe books\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe book COMMAND\n"
  printf "  recipe book [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "Commands:"
  printf "  %s   List recipe books\n" "list  "
  printf "  %s   Set a recipe book as global\n" "global"
  printf "  %s   Set a recipe book as local\n" "local "
  printf "  %s   Add a new recipe book\n" "add   "
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

recipe_book_list_usage() {
  printf "recipe book list - List recipe books\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe book list\n"
  printf "  recipe book list --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe book list\n"
    echo

  fi
}

recipe_book_global_usage() {
  printf "recipe book global - Set a recipe book as global\n\n"
  printf "Alias: g\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe book global RECIPE-BOOK\n"
  printf "  recipe book global --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "RECIPE-BOOK"
    printf "    Name of the recipe book\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe book global personal\n"
    echo

  fi
}

recipe_book_local_usage() {
  printf "recipe book local - Set a recipe book as local\n\n"
  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  recipe book local RECIPE-BOOK\n"
  printf "  recipe book local --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "RECIPE-BOOK"
    printf "    Name of the recipe book\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe book local personal\n"
    echo

  fi
}

recipe_book_add_usage() {
  printf "recipe book add - Add a new recipe book\n\n"

  printf "%s\n" "Usage:"
  printf "  recipe book add RECIPE-BOOK [REPOSITORY]\n"
  printf "  recipe book add --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "RECIPE-BOOK"
    printf "    Name of the recipe book\n"
    echo

    printf "  %s\n" "REPOSITORY"
    printf "    Remote repository url\n"
    echo

    printf "%s\n" "Examples:"
    printf "  recipe book add personal\n"
    echo

  fi
}

normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

clean_directory() {
    if [[ -d "${1}" ]] && [[ -z "$(ls -A "${1}")" ]]; then
        run_silent rmdir "${1}"
    fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

filter_recipe() {
    local recipes="$(find_recipe)"
    echo "${recipes}" | gum filter --placeholder "Select a recipe..."
}

filter_recipe_book_directory() {
    if [[ -z "${RECIPE_BOOK}" ]]; then
        error "global recipe book not set"
    elif [[ ! -d "${RECIPE_BOOK_DIR}" ]]; then
        error "global recipe book not found: ${RECIPE_BOOK}"
    fi
}

filter_recipe_book_git() {
    if [[ ! -d "${RECIPE_BOOK_DIR}/.git" ]]; then
        error "global recipe book is not a git repository"
    fi
}

filter_recipe_book_not_empty() {
    if [[ -z "$(list_recipes)" ]]; then
        error "global recipe book is empty"
    fi
}

interactive_diff() {
    candidates="$(run_git ls-files -mo --exclude-standard --full-name )"
    [[ -z "${candidates}" ]] && info 'no changes to diff' && return 0

    local files="$(echo "${candidates}" | gum filter --placeholder="Select files to diff" --no-limit)"
    [[ -z "${files}" ]] && return 0

    run_git diff "${files}"
}

interactive_staged_diff() {
    candidates="$(run_git diff --cached --name-only)"
    [[ -z "${candidates}" ]] && info 'no staged changes to diff' && return 0

    local files="$(echo "${candidates}" | gum filter --placeholder="Select files to diff" --no-limit)"
    [[ -z "${files}" ]] && return 0

    run_git diff --staged "${files}"
}

join() {
    echo "${1}" | tr '\n' ' '
}

error() {
    echo "$(red "recipe:") ${1}"
}

info() {
    echo "$(blue "recipe:") ${1}"
}

success() {
    echo "$(green "recipe:") ${1}"
}

warn() {
    echo "$(yellow "recipe:") ${1}"
}

pipe() {
    echo "${1}" | tr ' ' '\n'
}

list_recipes() {
    run_git ls-files --others --cached --modified
}

recipe_exists() {
    if [[ -f "${RECIPE_BOOK_DIR}/${1}" ]]; then
        return 0
    else
        return 1
    fi
}

run_git() {
    command "${deps[git]}" -C "${RECIPE_BOOK_DIR}" ${@}
}

run_silent() {
  command ${@} &> /dev/null
}

validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

validate_recipe_book_exists() {
    if [[ ! -d "${RECIPE_DATA_DIR}/shelf/${1}" ]]; then
        error "recipe book not found: ${1}"
    fi
}

validate_recipe_book_is_missing() {
    if [[ -d "${RECIPE_DATA_DIR}/shelf/${1}" ]]; then
        error "recipe book already exist: ${1}"
    fi
}

validate_recipe_exists() {
    if ! recipe_exists "${1}"; then
        error "recipe not found: ${1}"
    fi
}

validate_recipe_is_missing() {
    if [[ -f "${RECIPE_BOOK_DIR}/${1}" ]]; then
        error "recipe already exist: ${1}"
    fi
}

recipe_add_command() {
  local file="${args[file]}"
  local recipe="${args[name]:-$(basename "${file}")}"

  if recipe_exists "${recipe}"; then
      error "recipe already exists: ${recipe}"
      exit 1
  fi

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  if [[ "${recipe}" = */* ]]; then
      local recipe_dir="$(dirname "${recipe}")"

      # Directory in which the recipe will be stored
      local destination_dir="${RECIPE_BOOK_DIR}/${recipe_dir}"

      # Create intermediary directories if needed
      if [[ ! -d "${destination_dir}" ]]; then
          command mkdir -p "${destination_dir}"
      fi
  fi

  command cp "${file}" "${destination_path}"
  success "added recipe: ${recipe}"

}

recipe_list_command() {
  list_recipes

}

recipe_filter_command() {
  list_recipes | command "${deps[gum]}" filter --placeholder "Filter recipes"

}

recipe_use_command() {
  local recipe="${args[recipe]}"
  local destination="${args[destination]}"

  if [[ -z "${destination}" ]]; then
      destination="$(basename "${recipe}")"
  fi

  if [[ -f "${destination}" ]]; then
      error "recipe would overwrite ${destination}"
      exit 1
  fi

  destination_dir="$(dirname "${destination}")"

  if [[ ! "${destination_dir}" == '.' ]] && [[ ! -d "${destination_dir}" ]]; then
      command mkdir -p "${destination_dir}"
  fi

  command cp -f "${RECIPE_BOOK_DIR}/${recipe}" "${destination}"
  success "recipe ${destination} is ready to use"

}

recipe_remove_command() {
  local recipe=${args['name']}

  local recipe_dir="$(dirname ${recipe})"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  # Directory in which the recipe will be stored
  local destination_dir="${RECIPE_BOOK_DIR}/${recipe_dir}"

  run_silent rm "${destination_path}"
  clean_directory "${destination_dir}"

  success "removed recipe: ${recipe}"

}

recipe_edit_command() {
  local recipe="${args[name]}"

  local recipe_dir="$(dirname ${recipe})"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  # Directory in which the recipe will be stored
  local destination_dir="${RECIPE_BOOK_DIR}/${recipe_dir}"

  command "${EDITOR}" "${destination_path}"

}

recipe_show_command() {
  local recipe="${args[name]}"
  local command="${args[--exec]}"

  # Full destination path to the recipe
  local destination_path="${RECIPE_BOOK_DIR}/${recipe}"

  command ${command} "${destination_path}"

}

recipe_env_command() {
  echo "RECIPE_SHOW_CMD=${RECIPE_SHOW_CMD}"

}

recipe_status_command() {
  run_git status --short

}

recipe_stage_command() {
  candidates="$(run_git ls-files -mo --exclude-standard --full-name)"

  [[ -z "${candidates}" ]] && info "no changes to stage" && exit 0

  local files="$(pipe "${candidates}" \
      | gum filter --no-limit --fuzzy --placeholder="Select files to stage" )"

  [[ -z "${files}" ]] && exit 0

  files="$(join "${files}")"

  run_git add ${files} && success "staged ${files}"

}

recipe_unstage_command() {
  candidates="$(run_git diff --cached --name-only)"

  [[ -z "${candidates}" ]] && info "no changes to unstage" && return 0

  local files="$(echo "${candidates}" \
      | tr ' ' '\n' \
      | gum filter --no-limit --fuzzy --placeholder="Select files to unstage" )"

  [[ -z "${files}" ]] && return 0

  files="$(echo "${files}" | tr '\n' ' ')"

  run_git restore --staged ${files}  && success "unstaged ${files}"

}

recipe_restore_command() {
  candidates="$(run_git ls-files -mo --exclude-standard --full-name)"

  [[ -z "${candidates}" ]] && info "no changes to restore" && exit 0

  local files="$(echo "${candidates}" \
      | tr ' ' '\n' \
      | gum filter --no-limit --fuzzy --placeholder="Files to restore...")"

  [[ -z "${files}" ]] && exit 0

  files="$(echo "${files}" | tr '\n' ' ')"

  run_git restore ${files} && success "restored ${files}"

}

recipe_diff_command() {
  local staged="${args[--staged]}"

  if [[ -n "${staged}" ]]; then
      interactive_staged_diff
  else
      interactive_diff
  fi

}

recipe_commit_command() {
  local message="${args[message]}"

  run_git commit "${message}"

}

recipe_cd_command() {
  command cd "${RECIPE_BOOK_DIR}" && command "${SHELL}"

}

recipe_git_command() {
  run_git ${other_args[*]}

}

recipe_book_list_command() {
  for recipe_book in $(ls "${RECIPE_DATA_DIR}/shelf"); do
      if [[ "${recipe_book}" = "${RECIPE_BOOK}" ]]; then
          echo "$(green "*") ${recipe_book}"
      else
          echo "${recipe_book}"
      fi
  done

}

recipe_book_global_command() {
  local recipe_book="${args[recipe-book]}"

  echo "${recipe_book}" > "${RECIPE_BOOK_INDEX}"
  success "set global recipe book"

}

recipe_book_local_command() {
  local recipe_book="${args[recipe-book]}"

  echo "${recipe_book}" > ".recipe-book"
  success "set local recipe book"

}

recipe_book_add_command() {
  local recipe_book="${args[recipe-book]}"
  local repository="${args[repository]}"

  local path="${RECIPE_DATA_DIR}/shelf/${recipe_book}"

  if [[ -z "${repository}" ]]; then
      # If the repository is not provided, create a new recipe book
      command mkdir -p "${path}"
      command "${deps[git]}" -C "${path}" init

      success "added recipe book"
  else
      # Otherwise, clone the repository
      command "${deps[git]}" clone "${repository}" "${path}"
      success "added remote recipe book"
  fi

}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        recipe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  export EDITOR="${EDITOR:-vim}"
  export RECIPE_SHOW_CMD="${RECIPE_SHOW_CMD:-cat}"

  env_var_names+=("EDITOR")
  env_var_names+=("RECIPE_SHOW_CMD")

  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "$(red pm:) missing dependency: git\n" >&2
    exit 1
  fi

  if command -v gum >/dev/null 2>&1; then
    deps['gum']="$(command -v gum | head -n1)"
  else
    printf "$(red pm:) missing dependency: gum\n" >&2
    exit 1
  fi

  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      recipe_add_parse_requirements "$@"
      shift $#
      ;;

    list | ls)
      action="list"
      shift
      recipe_list_parse_requirements "$@"
      shift $#
      ;;

    filter)
      action="filter"
      shift
      recipe_filter_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      recipe_use_parse_requirements "$@"
      shift $#
      ;;

    remove | rm)
      action="remove"
      shift
      recipe_remove_parse_requirements "$@"
      shift $#
      ;;

    edit)
      action="edit"
      shift
      recipe_edit_parse_requirements "$@"
      shift $#
      ;;

    show)
      action="show"
      shift
      recipe_show_parse_requirements "$@"
      shift $#
      ;;

    env)
      action="env"
      shift
      recipe_env_parse_requirements "$@"
      shift $#
      ;;

    status | st)
      action="status"
      shift
      recipe_status_parse_requirements "$@"
      shift $#
      ;;

    stage)
      action="stage"
      shift
      recipe_stage_parse_requirements "$@"
      shift $#
      ;;

    unstage)
      action="unstage"
      shift
      recipe_unstage_parse_requirements "$@"
      shift $#
      ;;

    restore | rs | undo)
      action="restore"
      shift
      recipe_restore_parse_requirements "$@"
      shift $#
      ;;

    diff)
      action="diff"
      shift
      recipe_diff_parse_requirements "$@"
      shift $#
      ;;

    commit | ci)
      action="commit"
      shift
      recipe_commit_parse_requirements "$@"
      shift $#
      ;;

    cd)
      action="cd"
      shift
      recipe_cd_parse_requirements "$@"
      shift $#
      ;;

    git)
      action="git"
      shift
      recipe_git_parse_requirements "$@"
      shift $#
      ;;

    book)
      action="book"
      shift
      recipe_book_parse_requirements "$@"
      shift $#
      ;;

    "")
      recipe_usage >&2
      exit 1
      ;;

    *)
      printf "$(red pm:) invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

recipe_add_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="add"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['file']+x} ]]; then
          args['file']=$1
          shift

        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "$(red pm:) invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['file']+x} ]]; then
    printf "$(red pm:) missing required argument: FILE\nusage: recipe add FILE [NAME]\n" >&2

    exit 1
  fi

  if [[ -v args['file'] && -n $(validate_file_exists "${args['file']:-}") ]]; then
    printf "$(red pm:) validation error in %s:\n%s\n" "FILE" "$(validate_file_exists "${args['file']:-}")" >&2
    exit 1
  fi

  if [[ -v args['name'] && -n $(validate_recipe_is_missing "${args['name']:-}") ]]; then
    printf "$(red pm:) validation error in %s:\n%s\n" "NAME" "$(validate_recipe_is_missing "${args['name']:-}")" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_list_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="list"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_filter_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_filter_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="filter"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_use_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="use"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['recipe']+x} ]]; then
          args['recipe']=$1
          shift

        elif [[ -z ${args['destination']+x} ]]; then
          args['destination']=$1
          shift
        else
          printf "$(red pm:) invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['recipe']+x} ]]; then
    printf "$(red pm:) missing required argument: RECIPE\nusage: recipe use RECIPE [DESTINATION]\n" >&2

    exit 1
  fi

  if [[ -v args['recipe'] && -n $(validate_recipe_exists "${args['recipe']:-}") ]]; then
    printf "$(red pm:) validation error in %s:\n%s\n" "RECIPE" "$(validate_recipe_exists "${args['recipe']:-}")" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_not_empty)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_remove_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="remove"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "$(red pm:) invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['name']+x} ]]; then
    printf "$(red pm:) missing required argument: NAME\nusage: recipe remove NAME\n" >&2

    exit 1
  fi

  if [[ -v args['name'] && -n $(validate_recipe_exists "${args['name']:-}") ]]; then
    printf "$(red pm:) validation error in %s:\n%s\n" "NAME" "$(validate_recipe_exists "${args['name']:-}")" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_not_empty)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_edit_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="edit"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "$(red pm:) invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['name']+x} ]]; then
    printf "$(red pm:) missing required argument: NAME\nusage: recipe edit NAME\n" >&2

    exit 1
  fi

  if [[ -v args['name'] && -n $(validate_recipe_exists "${args['name']:-}") ]]; then
    printf "$(red pm:) validation error in %s:\n%s\n" "NAME" "$(validate_recipe_exists "${args['name']:-}")" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_not_empty)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_show_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="show"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --exec | -x)

        if [[ -n ${2+x} ]]; then
          args['--exec']="$2"
          shift
          shift
        else
          printf "%s\n" "$(red pm:) --exec requires an argument: --exec, -x EXECUTABLE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "$(red pm:) invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['name']+x} ]]; then
    printf "$(red pm:) missing required argument: NAME\nusage: recipe show NAME [OPTIONS]\n" >&2

    exit 1
  fi

  [[ -n ${args['--exec']:-} ]] || args['--exec']="${RECIPE_SHOW_CMD}"

  if [[ -v args['name'] && -n $(validate_recipe_exists "${args['name']:-}") ]]; then
    printf "$(red pm:) validation error in %s:\n%s\n" "NAME" "$(validate_recipe_exists "${args['name']:-}")" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_not_empty)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_env_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="env"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

recipe_status_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="status"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --short | -s)

        args['--short']=1
        shift
        ;;

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_stage_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_stage_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="stage"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_unstage_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_unstage_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="unstage"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_restore_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_restore_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="restore"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_diff_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_diff_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="diff"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --staged | -s)

        args['--staged']=1
        shift
        ;;

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_commit_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_commit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="commit"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['message']+x} ]]; then
          args['message']=$1
          shift
        else
          printf "$(red pm:) invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_cd_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_cd_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="cd"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_git_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_git_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="git"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)

        other_args+=("$1")
        shift

        ;;

    esac
  done

  if [[ ${#other_args[@]} -eq 0 ]]; then
    printf "$(red pm:) missing required argument: COMMANDS...\nusage: recipe git [--] COMMANDS...\n" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_directory)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_recipe_book_git)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

recipe_book_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_book_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    list | ls)
      action="list"
      shift
      recipe_book_list_parse_requirements "$@"
      shift $#
      ;;

    global | g)
      action="global"
      shift
      recipe_book_global_parse_requirements "$@"
      shift $#
      ;;

    local | l)
      action="local"
      shift
      recipe_book_local_parse_requirements "$@"
      shift $#
      ;;

    add)
      action="add"
      shift
      recipe_book_add_parse_requirements "$@"
      shift $#
      ;;

    "")
      recipe_book_usage >&2
      exit 1
      ;;

    *)
      printf "$(red pm:) invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

recipe_book_list_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_book_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="book list"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "$(red pm:) invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

recipe_book_global_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_book_global_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="book global"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['recipe-book']+x} ]]; then
          args['recipe-book']=$1
          shift
        else
          printf "$(red pm:) invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['recipe-book']+x} ]]; then
    printf "$(red pm:) missing required argument: RECIPE-BOOK\nusage: recipe book global RECIPE-BOOK\n" >&2

    exit 1
  fi

  if [[ -v args['recipe-book'] && -n $(validate_recipe_book_exists "${args['recipe-book']:-}") ]]; then
    printf "$(red pm:) validation error in %s:\n%s\n" "RECIPE-BOOK" "$(validate_recipe_book_exists "${args['recipe-book']:-}")" >&2
    exit 1
  fi

}

recipe_book_local_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_book_local_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="book local"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['recipe-book']+x} ]]; then
          args['recipe-book']=$1
          shift
        else
          printf "$(red pm:) invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['recipe-book']+x} ]]; then
    printf "$(red pm:) missing required argument: RECIPE-BOOK\nusage: recipe book local RECIPE-BOOK\n" >&2

    exit 1
  fi

  if [[ -v args['recipe-book'] && -n $(validate_recipe_book_exists "${args['recipe-book']:-}") ]]; then
    printf "$(red pm:) validation error in %s:\n%s\n" "RECIPE-BOOK" "$(validate_recipe_book_exists "${args['recipe-book']:-}")" >&2
    exit 1
  fi

}

recipe_book_add_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        recipe_book_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="book add"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "$(red pm:) invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['recipe-book']+x} ]]; then
          args['recipe-book']=$1
          shift

        elif [[ -z ${args['repository']+x} ]]; then
          args['repository']=$1
          shift
        else
          printf "$(red pm:) invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['recipe-book']+x} ]]; then
    printf "$(red pm:) missing required argument: RECIPE-BOOK\nusage: recipe book add RECIPE-BOOK [REPOSITORY]\n" >&2

    exit 1
  fi

  if [[ -v args['recipe-book'] && -n $(validate_recipe_book_is_missing "${args['recipe-book']:-}") ]]; then
    printf "$(red pm:) validation error in %s:\n%s\n" "RECIPE-BOOK" "$(validate_recipe_book_is_missing "${args['recipe-book']:-}")" >&2
    exit 1
  fi

}

initialize() {
  version="1.7.1"
  long_usage=''
  set -e

  export EDITOR="${EDITOR:-vim}"
  export RECIPE_SHOW_CMD="${RECIPE_SHOW_CMD:-cat}"

  # Define data dir here rather than in bashly.yaml to prevent users from
  # changing it.
  export RECIPE_DATA_DIR="${HOME}/.local/share/recipe"

  dirs=(
      "${RECIPE_DATA_DIR}/shelf"
  )

  #
  # Create directories if not present
  #
  for destination in ${dirs[*]}; do
      if [[ ! -d "${destination}" ]]; then
          command mkdir -p "${destination}"
      fi
  done

  if [[ -f ".recipe-book" ]]; then
      # File used to store the name of the current recipe book
      export RECIPE_BOOK_INDEX=".recipe-book"
  else
      # File used to store the name of the current recipe book
      export RECIPE_BOOK_INDEX="${RECIPE_DATA_DIR}/global-recipe-book"

      if [[ ! -f "${RECIPE_BOOK_INDEX}" ]]; then
          touch "${RECIPE_BOOK_INDEX}"
      fi
  fi

  # Name of the current recipe book
  export RECIPE_BOOK="$(cat "${RECIPE_BOOK_INDEX}")"

  # Path to the current recipe book
  export RECIPE_BOOK_DIR="${RECIPE_DATA_DIR}/shelf/${RECIPE_BOOK}"

}

run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "add") recipe_add_command ;;
    "list") recipe_list_command ;;
    "filter") recipe_filter_command ;;
    "use") recipe_use_command ;;
    "remove") recipe_remove_command ;;
    "edit") recipe_edit_command ;;
    "show") recipe_show_command ;;
    "env") recipe_env_command ;;
    "status") recipe_status_command ;;
    "stage") recipe_stage_command ;;
    "unstage") recipe_unstage_command ;;
    "restore") recipe_restore_command ;;
    "diff") recipe_diff_command ;;
    "commit") recipe_commit_command ;;
    "cd") recipe_cd_command ;;
    "git") recipe_git_command ;;
    "book") recipe_book_command ;;
    "book list") recipe_book_list_command ;;
    "book global") recipe_book_global_command ;;
    "book local") recipe_book_local_command ;;
    "book add") recipe_book_add_command ;;
  esac
}

initialize
run "$@"
